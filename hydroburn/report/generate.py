"""
Report generation module.

Generates Markdown and HTML reports summarizing the analysis results.
"""

import pandas as pd
import numpy as np
from pathlib import Path
from typing import Dict, Any
from datetime import datetime
import markdown
from ..config import HydroBurnConfig

REPORT_TEMPLATE = """
# HydroBurn Analysis Report

**Project:** {fire_name} Post-Wildfire Analysis  
**Station:** {station_name} ({station_id})  
**Fire Date:** {fire_date}  
**Analysis Date:** {analysis_date}  

---

## 1. Executive Summary

This report analyzes the hydrologic impacts of the {fire_name} on the {station_name} watershed. 
The analysis compares pre-fire streamflow characteristics (1939–2024) with post-fire response (2024–2025).

### Key Findings

- **Peak Flows:** {peak_flow_change}
- **Runoff Volume:** {volume_change}
- **Flood Risk:** {flood_risk_change}
- **Baseflow:** {baseflow_change}

---

## 2. Data Overview

- **Catchment Area:** {area_km2:.2f} km²
- **Pre-fire Record:** {pre_start} to {pre_end} ({pre_years:.1f} years)
- **Post-fire Record:** {post_start} to {post_end} ({post_years:.1f} years)
- **Total Events Analyzed:** {n_events} ({n_pre} pre-fire, {n_post} post-fire)

![Hydrograph](figures/fig01_hydrograph.png)
*Figure 1: Full streamflow hydrograph with fire date indicated.*

---

## 3. Hydrologic Change Detection

### 3.1 Flow Duration Curves

The flow duration curve (FDC) comparison shows shifts in the hydrologic regime across flow magnitudes.

![FDC Comparison](figures/fig03_fdc_comparison.png)
*Figure 2: Flow duration curves for pre-fire and post-fire periods.*

**Key Percentile Changes:**

| Percentile | Pre-fire (m³/s) | Post-fire (m³/s) | Change (%) | Ratio |
|------------|-----------------|------------------|------------|-------|
{fdc_table}

### 3.2 Event Characteristics

Analysis of {n_events} storm events reveals changes in runoff response.

![Event Boxplots](figures/fig06_event_boxplots.png)
*Figure 3: Distribution of event metrics before and after the fire.*

**Statistical Comparison:**

| Metric | Pre-fire Mean | Post-fire Mean | Change (%) | Significance |
|--------|---------------|----------------|------------|--------------|
{stats_table}

---

## 4. Flood Frequency Analysis

Flood frequency analysis using the Gumbel distribution estimates changes in flood risk.

![Flood Frequency](figures/fig05_flood_frequency.png)
*Figure 4: Flood frequency curves with 95% confidence intervals.*

**Flood Quantile Estimates:**

| Return Period | Pre-fire (m³/s) | Post-fire (m³/s) | Ratio (Post/Pre) | 95% CI |
|---------------|-----------------|------------------|------------------|--------|
{flood_table}

---

## 5. Baseflow and Seasonality

Changes in baseflow contribution and seasonal patterns.

![Baseflow Index](figures/fig07_baseflow_index.png)
*Figure 5: Annual Baseflow Index (BFI) time series.*

![Monthly Distribution](figures/fig10_monthly_stats.png)
*Figure 6: Monthly flow distributions.*

---

## 6. Conclusions & Recommendations

Based on the analysis of {post_years:.1f} years of post-fire data:

1. **Flood Hazard:** {flood_conclusion}
2. **Runoff Response:** {runoff_conclusion}
3. **Recommendations:**
   - Continue monitoring to track recovery
   - Update flood hazard maps if Q100 increase is significant
   - Consider post-fire specific CN values for modeling

---

*Generated by HydroBurn v{version}*
"""

def format_fdc_table(fdc_df: pd.DataFrame) -> str:
    """Format FDC table for Markdown."""
    rows = []
    for _, row in fdc_df.iterrows():
        rows.append(
            f"| Q{int(row['exceedance_pct'])} | {row['pre_discharge']:.2f} | "
            f"{row['post_discharge']:.2f} | {row['change_pct']:+.1f}% | {row['ratio']:.2f} |"
        )
    return "\n".join(rows)

def format_stats_table(stats_df: pd.DataFrame) -> str:
    """Format statistics table for Markdown."""
    rows = []
    for _, row in stats_df.iterrows():
        sig = "Significant" if row.get('pvalue', 1.0) < 0.05 else "Not Sig."
        
        pre_mean = row.get('pre_mean')
        post_mean = row.get('post_mean')
        change_pct = row.get('change_mean_pct')
        
        pre_str = f"{pre_mean:.2f}" if pre_mean is not None else "N/A"
        post_str = f"{post_mean:.2f}" if post_mean is not None else "N/A"
        change_str = f"{change_pct:+.1f}%" if change_pct is not None else "N/A"
        
        rows.append(
            f"| {row['metric']} | {pre_str} | {post_str} | "
            f"{change_str} | {sig} |"
        )
    return "\n".join(rows)

def format_flood_table(flood_df: pd.DataFrame) -> str:
    """Format flood frequency table for Markdown."""
    rows = []
    for _, row in flood_df.iterrows():
        rows.append(
            f"| {int(row['return_period'])}-yr | {row['pre_estimate']:.1f} | "
            f"{row['post_estimate']:.1f} | {row['ratio']:.2f} | "
            f"[{row['ratio_ci_lower']:.2f} - {row['ratio_ci_upper']:.2f}] |"
        )
    return "\n".join(rows)

def generate_report(
    config: HydroBurnConfig,
    results: Dict[str, Any],
    output_path: Path
):
    """
    Generate Markdown and HTML reports.
    
    Parameters
    ----------
    config : HydroBurnConfig
        Configuration object
    results : dict
        Dictionary containing analysis results (DataFrames, stats)
    output_path : Path
        Path to save report.md
    """
    # Extract data for template
    fdc_df = results.get('fdc_comparison', pd.DataFrame())
    stats_df = results.get('event_stats', pd.DataFrame())
    flood_df = results.get('flood_quantiles', pd.DataFrame())
    
    # Determine key findings (simple logic)
    peak_change_row = stats_df[stats_df['metric'] == 'Peak Discharge (m³/s)']
    peak_change = peak_change_row['change_mean_pct'].iloc[0] if not peak_change_row.empty else 0
    if peak_change is None: peak_change = 0
    
    vol_change_row = stats_df[stats_df['metric'] == 'Event Volume (mm)']
    vol_change = vol_change_row['change_mean_pct'].iloc[0] if not vol_change_row.empty else 0
    if vol_change is None: vol_change = 0
        
    q100_ratio_row = flood_df[flood_df['return_period'] == 100]
    q100_ratio = q100_ratio_row['ratio'].iloc[0] if not q100_ratio_row.empty else 1.0
    if q100_ratio is None: q100_ratio = 1.0
    
    # Fill template
    content = REPORT_TEMPLATE.format(
        fire_name=config.fire_name,
        station_name=config.station_name,
        station_id=config.station_id,
        fire_date=config.fire_date,
        analysis_date=datetime.now().strftime("%Y-%m-%d"),
        area_km2=config.catchment_area_km2 or 0.0,
        
        # Data overview
        pre_start=results.get('pre_start', 'N/A'),
        pre_end=results.get('pre_end', 'N/A'),
        pre_years=results.get('pre_years', 0),
        post_start=results.get('post_start', 'N/A'),
        post_end=results.get('post_end', 'N/A'),
        post_years=results.get('post_years', 0),
        n_events=results.get('n_events', 0),
        n_pre=results.get('n_pre_events', 0),
        n_post=results.get('n_post_events', 0),
        
        # Findings
        peak_flow_change=f"{peak_change:+.1f}% change in mean peak discharge",
        volume_change=f"{vol_change:+.1f}% change in mean event volume",
        flood_risk_change=f"100-year flood ratio: {q100_ratio:.2f}x",
        baseflow_change="See BFI analysis",
        
        # Tables
        fdc_table=format_fdc_table(fdc_df),
        stats_table=format_stats_table(stats_df),
        flood_table=format_flood_table(flood_df),
        
        # Conclusions
        flood_conclusion=f"Flood risk has {'increased' if q100_ratio > 1.1 else 'remained stable'} "
                         f"(Ratio: {q100_ratio:.2f})",
        runoff_conclusion=f"Watershed response is {'flashier' if peak_change > 10 else 'similar'} "
                          f"post-fire",
        
        version="1.0.0"
    )
    
    # Write Markdown
    with open(output_path, 'w') as f:
        f.write(content)
    
    # Generate HTML
    if config.generate_html_report:
        html_path = output_path.with_suffix('.html')
        html_content = markdown.markdown(content, extensions=['tables'])
        
        # Add simple CSS
        html_wrapper = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>HydroBurn Report - {config.fire_name}</title>
            <style>
                body {{ font-family: Arial, sans-serif; max-width: 900px; margin: 0 auto; padding: 20px; line-height: 1.6; }}
                h1, h2, h3 {{ color: #2c3e50; }}
                table {{ border-collapse: collapse; width: 100%; margin: 20px 0; }}
                th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
                th {{ background-color: #f2f2f2; }}
                tr:nth-child(even) {{ background-color: #f9f9f9; }}
                img {{ max-width: 100%; height: auto; border: 1px solid #ddd; box-shadow: 2px 2px 5px rgba(0,0,0,0.1); }}
                .warning {{ color: #e74c3c; font-weight: bold; }}
            </style>
        </head>
        <body>
            {html_content}
        </body>
        </html>
        """
        
        with open(html_path, 'w') as f:
            f.write(html_wrapper)

def generate_html_report(md_path: str, html_path: str):
    """Convert existing Markdown report to HTML."""
    with open(md_path, 'r') as f:
        text = f.read()
    
    html = markdown.markdown(text, extensions=['tables'])
    
    with open(html_path, 'w') as f:
        f.write(html)
